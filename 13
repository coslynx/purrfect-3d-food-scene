import { useState, useEffect, useRef, useCallback } from 'react'
import * as THREE from 'three'
import { useFrame, useThree } from '@react-three/fiber'
import { AnimationClip, AnimationMixer } from 'three'
type AnimationClipType = {name: string;clip: THREE.AnimationClip}
interface Use3DAnimationResult{playAnimation: (name: string) => void;pauseAnimation: (name: string) => void;stopAnimation: (name: string) => void}
export const use3DAnimation = (model:THREE.Object3D|null):Use3DAnimationResult => {const mixer = useRef<THREE.AnimationMixer|null>(null)const animationClips = useRef<AnimationClipType[]>([])const [playing, setPlaying] = useState<boolean>(false)const {scene} = useThree()useEffect(() => {if (!model) return;mixer.current = new THREE.AnimationMixer(model)animationClips.current = model.animations.map((clip: AnimationClip) => ({name: clip.name,clip: clip}))return () => {mixer.current?.uncacheRoot(model);mixer.current?.stopAllAction();mixer.current=null}}, [model])useFrame((state, delta) => {mixer.current?.update(delta)})const playAnimation = useCallback((name: string) => {if (!mixer.current) return;const clip = animationClips.current.find((c) => c.name === name)?.clipif (!clip) return;const action = mixer.current.clipAction(clip)action.reset().play();setPlaying(true)}, [animationClips])const pauseAnimation = useCallback((name: string) => {if (!mixer.current) return;const clip = animationClips.current.find((c) => c.name === name)?.clipif (!clip) return;const action = mixer.current.clipAction(clip)action.pause();setPlaying(false)}, [animationClips])const stopAnimation = useCallback((name: string) => {if (!mixer.current) return;const clip = animationClips.current.find((c) => c.name === name)?.clipif (!clip) return;const action = mixer.current.clipAction(clip)action.stop();setPlaying(false)}, [animationClips])return {playAnimation,pauseAnimation,stopAnimation}}